// Code generated by mockery v2.52.3. DO NOT EDIT.

package mocks

import (
	context "context"

	qb "github.com/antibomberman/qb"
	mock "github.com/stretchr/testify/mock"

	time "time"
)

// BuilderInterface is an autogenerated mock type for the BuilderInterface type
type BuilderInterface struct {
	mock.Mock
}

// As provides a mock function with given fields: alias
func (_m *BuilderInterface) As(alias string) *qb.Builder {
	ret := _m.Called(alias)

	if len(ret) == 0 {
		panic("no return value specified for As")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string) *qb.Builder); ok {
		r0 = rf(alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Avg provides a mock function with given fields: column
func (_m *BuilderInterface) Avg(column string) (float64, error) {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Avg")
	}

	var r0 float64
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (float64, error)); ok {
		return rf(column)
	}
	if rf, ok := ret.Get(0).(func(string) float64); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(float64)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(column)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchInsert provides a mock function with given fields: records
func (_m *BuilderInterface) BatchInsert(records []map[string]interface{}) error {
	ret := _m.Called(records)

	if len(ret) == 0 {
		panic("no return value specified for BatchInsert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]map[string]interface{}) error); ok {
		r0 = rf(records)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BatchInsertAsync provides a mock function with given fields: records
func (_m *BuilderInterface) BatchInsertAsync(records []map[string]interface{}) chan error {
	ret := _m.Called(records)

	if len(ret) == 0 {
		panic("no return value specified for BatchInsertAsync")
	}

	var r0 chan error
	if rf, ok := ret.Get(0).(func([]map[string]interface{}) chan error); ok {
		r0 = rf(records)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan error)
		}
	}

	return r0
}

// BatchUpdate provides a mock function with given fields: records, keyColumn, batchSize
func (_m *BuilderInterface) BatchUpdate(records []map[string]interface{}, keyColumn string, batchSize int) error {
	ret := _m.Called(records, keyColumn, batchSize)

	if len(ret) == 0 {
		panic("no return value specified for BatchUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]map[string]interface{}, string, int) error); ok {
		r0 = rf(records, keyColumn, batchSize)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BulkInsert provides a mock function with given fields: records
func (_m *BuilderInterface) BulkInsert(records []map[string]interface{}) error {
	ret := _m.Called(records)

	if len(ret) == 0 {
		panic("no return value specified for BulkInsert")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]map[string]interface{}) error); ok {
		r0 = rf(records)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BulkInsertAsync provides a mock function with given fields: records
func (_m *BuilderInterface) BulkInsertAsync(records []map[string]interface{}) chan error {
	ret := _m.Called(records)

	if len(ret) == 0 {
		panic("no return value specified for BulkInsertAsync")
	}

	var r0 chan error
	if rf, ok := ret.Get(0).(func([]map[string]interface{}) chan error); ok {
		r0 = rf(records)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan error)
		}
	}

	return r0
}

// BulkUpdate provides a mock function with given fields: records, keyColumn
func (_m *BuilderInterface) BulkUpdate(records []map[string]interface{}, keyColumn string) error {
	ret := _m.Called(records, keyColumn)

	if len(ret) == 0 {
		panic("no return value specified for BulkUpdate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func([]map[string]interface{}, string) error); ok {
		r0 = rf(records, keyColumn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// BulkUpdateAsync provides a mock function with given fields: records, keyColumn
func (_m *BuilderInterface) BulkUpdateAsync(records []map[string]interface{}, keyColumn string) chan error {
	ret := _m.Called(records, keyColumn)

	if len(ret) == 0 {
		panic("no return value specified for BulkUpdateAsync")
	}

	var r0 chan error
	if rf, ok := ret.Get(0).(func([]map[string]interface{}, string) chan error); ok {
		r0 = rf(records, keyColumn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan error)
		}
	}

	return r0
}

// Chunk provides a mock function with given fields: size, fn
func (_m *BuilderInterface) Chunk(size int, fn func(interface{}) error) error {
	ret := _m.Called(size, fn)

	if len(ret) == 0 {
		panic("no return value specified for Chunk")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(int, func(interface{}) error) error); ok {
		r0 = rf(size, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ChunkContext provides a mock function with given fields: ctx, size, fn
func (_m *BuilderInterface) ChunkContext(ctx context.Context, size int, fn func(context.Context, interface{}) error) error {
	ret := _m.Called(ctx, size, fn)

	if len(ret) == 0 {
		panic("no return value specified for ChunkContext")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, int, func(context.Context, interface{}) error) error); ok {
		r0 = rf(ctx, size, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Context provides a mock function with given fields: ctx
func (_m *BuilderInterface) Context(ctx context.Context) *qb.Builder {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Context")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(context.Context) *qb.Builder); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Count provides a mock function with no fields
func (_m *BuilderInterface) Count() (int64, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Count")
	}

	var r0 int64
	var r1 error
	if rf, ok := ret.Get(0).(func() (int64, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() int64); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int64)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Create provides a mock function with given fields: data, fields
func (_m *BuilderInterface) Create(data interface{}, fields ...string) (interface{}, error) {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Create")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, ...string) (interface{}, error)); ok {
		return rf(data, fields...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...string) interface{}); ok {
		r0 = rf(data, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...string) error); ok {
		r1 = rf(data, fields...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateAsync provides a mock function with given fields: data, fields
func (_m *BuilderInterface) CreateAsync(data interface{}, fields ...string) (chan interface{}, chan error) {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for CreateAsync")
	}

	var r0 chan interface{}
	var r1 chan error
	if rf, ok := ret.Get(0).(func(interface{}, ...string) (chan interface{}, chan error)); ok {
		return rf(data, fields...)
	}
	if rf, ok := ret.Get(0).(func(interface{}, ...string) chan interface{}); ok {
		r0 = rf(data, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, ...string) chan error); ok {
		r1 = rf(data, fields...)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(chan error)
		}
	}

	return r0, r1
}

// CreateMap provides a mock function with given fields: data
func (_m *BuilderInterface) CreateMap(data map[string]interface{}) (interface{}, error) {
	ret := _m.Called(data)

	if len(ret) == 0 {
		panic("no return value specified for CreateMap")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) (interface{}, error)); ok {
		return rf(data)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}) interface{}); ok {
		r0 = rf(data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}) error); ok {
		r1 = rf(data)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMapAsync provides a mock function with given fields: data
func (_m *BuilderInterface) CreateMapAsync(data map[string]interface{}) (chan interface{}, chan error) {
	ret := _m.Called(data)

	if len(ret) == 0 {
		panic("no return value specified for CreateMapAsync")
	}

	var r0 chan interface{}
	var r1 chan error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) (chan interface{}, chan error)); ok {
		return rf(data)
	}
	if rf, ok := ret.Get(0).(func(map[string]interface{}) chan interface{}); ok {
		r0 = rf(data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(map[string]interface{}) chan error); ok {
		r1 = rf(data)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(chan error)
		}
	}

	return r0, r1
}

// CrossJoin provides a mock function with given fields: table
func (_m *BuilderInterface) CrossJoin(table string) *qb.Builder {
	ret := _m.Called(table)

	if len(ret) == 0 {
		panic("no return value specified for CrossJoin")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string) *qb.Builder); ok {
		r0 = rf(table)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Decrement provides a mock function with given fields: column, value
func (_m *BuilderInterface) Decrement(column string, value interface{}) error {
	ret := _m.Called(column, value)

	if len(ret) == 0 {
		panic("no return value specified for Decrement")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(column, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Delete provides a mock function with no fields
func (_m *BuilderInterface) Delete() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Delete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteAsync provides a mock function with no fields
func (_m *BuilderInterface) DeleteAsync() chan error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for DeleteAsync")
	}

	var r0 chan error
	if rf, ok := ret.Get(0).(func() chan error); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan error)
		}
	}

	return r0
}

// DenseRank provides a mock function with given fields: partition, orderBy, alias
func (_m *BuilderInterface) DenseRank(partition string, orderBy string, alias string) *qb.Builder {
	ret := _m.Called(partition, orderBy, alias)

	if len(ret) == 0 {
		panic("no return value specified for DenseRank")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, string) *qb.Builder); ok {
		r0 = rf(partition, orderBy, alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Distinct provides a mock function with given fields: columns
func (_m *BuilderInterface) Distinct(columns ...string) *qb.Builder {
	_va := make([]interface{}, len(columns))
	for _i := range columns {
		_va[_i] = columns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Distinct")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(...string) *qb.Builder); ok {
		r0 = rf(columns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Exists provides a mock function with no fields
func (_m *BuilderInterface) Exists() (bool, error) {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Exists")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func() (bool, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() bool); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Find provides a mock function with given fields: id, dest
func (_m *BuilderInterface) Find(id interface{}, dest interface{}) (bool, error) {
	ret := _m.Called(id, dest)

	if len(ret) == 0 {
		panic("no return value specified for Find")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}) (bool, error)); ok {
		return rf(id, dest)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}) bool); ok {
		r0 = rf(id, dest)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}) error); ok {
		r1 = rf(id, dest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindAsync provides a mock function with given fields: id, dest
func (_m *BuilderInterface) FindAsync(id interface{}, dest interface{}) (chan bool, chan error) {
	ret := _m.Called(id, dest)

	if len(ret) == 0 {
		panic("no return value specified for FindAsync")
	}

	var r0 chan bool
	var r1 chan error
	if rf, ok := ret.Get(0).(func(interface{}, interface{}) (chan bool, chan error)); ok {
		return rf(id, dest)
	}
	if rf, ok := ret.Get(0).(func(interface{}, interface{}) chan bool); ok {
		r0 = rf(id, dest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan bool)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}, interface{}) chan error); ok {
		r1 = rf(id, dest)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(chan error)
		}
	}

	return r0, r1
}

// First provides a mock function with given fields: dest
func (_m *BuilderInterface) First(dest interface{}) (bool, error) {
	ret := _m.Called(dest)

	if len(ret) == 0 {
		panic("no return value specified for First")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}) (bool, error)); ok {
		return rf(dest)
	}
	if rf, ok := ret.Get(0).(func(interface{}) bool); ok {
		r0 = rf(dest)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(interface{}) error); ok {
		r1 = rf(dest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FirstAsync provides a mock function with given fields: dest
func (_m *BuilderInterface) FirstAsync(dest interface{}) (chan bool, chan error) {
	ret := _m.Called(dest)

	if len(ret) == 0 {
		panic("no return value specified for FirstAsync")
	}

	var r0 chan bool
	var r1 chan error
	if rf, ok := ret.Get(0).(func(interface{}) (chan bool, chan error)); ok {
		return rf(dest)
	}
	if rf, ok := ret.Get(0).(func(interface{}) chan bool); ok {
		r0 = rf(dest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan bool)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}) chan error); ok {
		r1 = rf(dest)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(chan error)
		}
	}

	return r0, r1
}

// GeoSearch provides a mock function with given fields: column, point, radius
func (_m *BuilderInterface) GeoSearch(column string, point qb.Point, radius float64) *qb.Builder {
	ret := _m.Called(column, point, radius)

	if len(ret) == 0 {
		panic("no return value specified for GeoSearch")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, qb.Point, float64) *qb.Builder); ok {
		r0 = rf(column, point, radius)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Get provides a mock function with given fields: dest
func (_m *BuilderInterface) Get(dest interface{}) (bool, error) {
	ret := _m.Called(dest)

	if len(ret) == 0 {
		panic("no return value specified for Get")
	}

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(interface{}) (bool, error)); ok {
		return rf(dest)
	}
	if rf, ok := ret.Get(0).(func(interface{}) bool); ok {
		r0 = rf(dest)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(interface{}) error); ok {
		r1 = rf(dest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetAsync provides a mock function with given fields: dest
func (_m *BuilderInterface) GetAsync(dest interface{}) (chan bool, chan error) {
	ret := _m.Called(dest)

	if len(ret) == 0 {
		panic("no return value specified for GetAsync")
	}

	var r0 chan bool
	var r1 chan error
	if rf, ok := ret.Get(0).(func(interface{}) (chan bool, chan error)); ok {
		return rf(dest)
	}
	if rf, ok := ret.Get(0).(func(interface{}) chan bool); ok {
		r0 = rf(dest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan bool)
		}
	}

	if rf, ok := ret.Get(1).(func(interface{}) chan error); ok {
		r1 = rf(dest)
	} else {
		if ret.Get(1) != nil {
			r1 = ret.Get(1).(chan error)
		}
	}

	return r0, r1
}

// GroupBy provides a mock function with given fields: columns
func (_m *BuilderInterface) GroupBy(columns ...string) *qb.Builder {
	_va := make([]interface{}, len(columns))
	for _i := range columns {
		_va[_i] = columns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for GroupBy")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(...string) *qb.Builder); ok {
		r0 = rf(columns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Having provides a mock function with given fields: condition
func (_m *BuilderInterface) Having(condition string) *qb.Builder {
	ret := _m.Called(condition)

	if len(ret) == 0 {
		panic("no return value specified for Having")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string) *qb.Builder); ok {
		r0 = rf(condition)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// HavingRaw provides a mock function with given fields: sql, args
func (_m *BuilderInterface) HavingRaw(sql string, args ...interface{}) *qb.Builder {
	var _ca []interface{}
	_ca = append(_ca, sql)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for HavingRaw")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *qb.Builder); ok {
		r0 = rf(sql, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Increment provides a mock function with given fields: column, value
func (_m *BuilderInterface) Increment(column string, value interface{}) error {
	ret := _m.Called(column, value)

	if len(ret) == 0 {
		panic("no return value specified for Increment")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(column, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Join provides a mock function with given fields: table, condition
func (_m *BuilderInterface) Join(table string, condition string) *qb.Builder {
	ret := _m.Called(table, condition)

	if len(ret) == 0 {
		panic("no return value specified for Join")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string) *qb.Builder); ok {
		r0 = rf(table, condition)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// LeftJoin provides a mock function with given fields: table, condition
func (_m *BuilderInterface) LeftJoin(table string, condition string) *qb.Builder {
	ret := _m.Called(table, condition)

	if len(ret) == 0 {
		panic("no return value specified for LeftJoin")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string) *qb.Builder); ok {
		r0 = rf(table, condition)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Limit provides a mock function with given fields: limit
func (_m *BuilderInterface) Limit(limit int) *qb.Builder {
	ret := _m.Called(limit)

	if len(ret) == 0 {
		panic("no return value specified for Limit")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(int) *qb.Builder); ok {
		r0 = rf(limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Lock provides a mock function with given fields: mode
func (_m *BuilderInterface) Lock(mode string) *qb.Builder {
	ret := _m.Called(mode)

	if len(ret) == 0 {
		panic("no return value specified for Lock")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string) *qb.Builder); ok {
		r0 = rf(mode)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// LockForShare provides a mock function with no fields
func (_m *BuilderInterface) LockForShare() *qb.Builder {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LockForShare")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func() *qb.Builder); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// LockForUpdate provides a mock function with no fields
func (_m *BuilderInterface) LockForUpdate() *qb.Builder {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LockForUpdate")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func() *qb.Builder); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Max provides a mock function with given fields: column
func (_m *BuilderInterface) Max(column string) (float64, error) {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Max")
	}

	var r0 float64
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (float64, error)); ok {
		return rf(column)
	}
	if rf, ok := ret.Get(0).(func(string) float64); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(float64)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(column)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Min provides a mock function with given fields: column
func (_m *BuilderInterface) Min(column string) (float64, error) {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Min")
	}

	var r0 float64
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (float64, error)); ok {
		return rf(column)
	}
	if rf, ok := ret.Get(0).(func(string) float64); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(float64)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(column)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NoWait provides a mock function with no fields
func (_m *BuilderInterface) NoWait() *qb.Builder {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for NoWait")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func() *qb.Builder); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Offset provides a mock function with given fields: offset
func (_m *BuilderInterface) Offset(offset int) *qb.Builder {
	ret := _m.Called(offset)

	if len(ret) == 0 {
		panic("no return value specified for Offset")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(int) *qb.Builder); ok {
		r0 = rf(offset)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// On provides a mock function with given fields: event, handler
func (_m *BuilderInterface) On(event qb.EventType, handler qb.EventHandler) {
	_m.Called(event, handler)
}

// OnlyTrashed provides a mock function with no fields
func (_m *BuilderInterface) OnlyTrashed() *qb.Builder {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for OnlyTrashed")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func() *qb.Builder); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// OrWhere provides a mock function with given fields: condition, args
func (_m *BuilderInterface) OrWhere(condition string, args ...interface{}) *qb.Builder {
	var _ca []interface{}
	_ca = append(_ca, condition)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for OrWhere")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *qb.Builder); ok {
		r0 = rf(condition, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// OrWhereGroup provides a mock function with given fields: fn
func (_m *BuilderInterface) OrWhereGroup(fn func(*qb.Builder)) *qb.Builder {
	ret := _m.Called(fn)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereGroup")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(func(*qb.Builder)) *qb.Builder); ok {
		r0 = rf(fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// OrWhereRaw provides a mock function with given fields: sql, args
func (_m *BuilderInterface) OrWhereRaw(sql string, args ...interface{}) *qb.Builder {
	var _ca []interface{}
	_ca = append(_ca, sql)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for OrWhereRaw")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *qb.Builder); ok {
		r0 = rf(sql, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// OrderBy provides a mock function with given fields: column, direction
func (_m *BuilderInterface) OrderBy(column string, direction string) *qb.Builder {
	ret := _m.Called(column, direction)

	if len(ret) == 0 {
		panic("no return value specified for OrderBy")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string) *qb.Builder); ok {
		r0 = rf(column, direction)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Paginate provides a mock function with given fields: page, perPage, dest
func (_m *BuilderInterface) Paginate(page int, perPage int, dest interface{}) (*qb.PaginationResult, error) {
	ret := _m.Called(page, perPage, dest)

	if len(ret) == 0 {
		panic("no return value specified for Paginate")
	}

	var r0 *qb.PaginationResult
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int, interface{}) (*qb.PaginationResult, error)); ok {
		return rf(page, perPage, dest)
	}
	if rf, ok := ret.Get(0).(func(int, int, interface{}) *qb.PaginationResult); ok {
		r0 = rf(page, perPage, dest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.PaginationResult)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int, interface{}) error); ok {
		r1 = rf(page, perPage, dest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaginateWithCursor provides a mock function with given fields: cursor, limit, dest
func (_m *BuilderInterface) PaginateWithCursor(cursor string, limit int, dest interface{}) (*qb.CursorPagination, error) {
	ret := _m.Called(cursor, limit, dest)

	if len(ret) == 0 {
		panic("no return value specified for PaginateWithCursor")
	}

	var r0 *qb.CursorPagination
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, interface{}) (*qb.CursorPagination, error)); ok {
		return rf(cursor, limit, dest)
	}
	if rf, ok := ret.Get(0).(func(string, int, interface{}) *qb.CursorPagination); ok {
		r0 = rf(cursor, limit, dest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.CursorPagination)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int, interface{}) error); ok {
		r1 = rf(cursor, limit, dest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PaginateWithToken provides a mock function with given fields: token, limit, dest
func (_m *BuilderInterface) PaginateWithToken(token string, limit int, dest interface{}) (*qb.PaginationTokenResult, error) {
	ret := _m.Called(token, limit, dest)

	if len(ret) == 0 {
		panic("no return value specified for PaginateWithToken")
	}

	var r0 *qb.PaginationTokenResult
	var r1 error
	if rf, ok := ret.Get(0).(func(string, int, interface{}) (*qb.PaginationTokenResult, error)); ok {
		return rf(token, limit, dest)
	}
	if rf, ok := ret.Get(0).(func(string, int, interface{}) *qb.PaginationTokenResult); ok {
		r0 = rf(token, limit, dest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.PaginationTokenResult)
		}
	}

	if rf, ok := ret.Get(1).(func(string, int, interface{}) error); ok {
		r1 = rf(token, limit, dest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Pluck provides a mock function with given fields: column, dest
func (_m *BuilderInterface) Pluck(column string, dest interface{}) error {
	ret := _m.Called(column, dest)

	if len(ret) == 0 {
		panic("no return value specified for Pluck")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}) error); ok {
		r0 = rf(column, dest)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// ProcessQueue provides a mock function with given fields: handler
func (_m *BuilderInterface) ProcessQueue(handler func(qb.QueuedOperation) error) error {
	ret := _m.Called(handler)

	if len(ret) == 0 {
		panic("no return value specified for ProcessQueue")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(func(qb.QueuedOperation) error) error); ok {
		r0 = rf(handler)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Queue provides a mock function with given fields: operation, data, runAt
func (_m *BuilderInterface) Queue(operation string, data interface{}, runAt time.Time) error {
	ret := _m.Called(operation, data, runAt)

	if len(ret) == 0 {
		panic("no return value specified for Queue")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, interface{}, time.Time) error); ok {
		r0 = rf(operation, data, runAt)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Rank provides a mock function with given fields: partition, orderBy, alias
func (_m *BuilderInterface) Rank(partition string, orderBy string, alias string) *qb.Builder {
	ret := _m.Called(partition, orderBy, alias)

	if len(ret) == 0 {
		panic("no return value specified for Rank")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, string) *qb.Builder); ok {
		r0 = rf(partition, orderBy, alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Restore provides a mock function with no fields
func (_m *BuilderInterface) Restore() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Restore")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RightJoin provides a mock function with given fields: table, condition
func (_m *BuilderInterface) RightJoin(table string, condition string) *qb.Builder {
	ret := _m.Called(table, condition)

	if len(ret) == 0 {
		panic("no return value specified for RightJoin")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string) *qb.Builder); ok {
		r0 = rf(table, condition)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// RowNumber provides a mock function with given fields: partition, orderBy, alias
func (_m *BuilderInterface) RowNumber(partition string, orderBy string, alias string) *qb.Builder {
	ret := _m.Called(partition, orderBy, alias)

	if len(ret) == 0 {
		panic("no return value specified for RowNumber")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, string) *qb.Builder); ok {
		r0 = rf(partition, orderBy, alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Search provides a mock function with given fields: columns, query
func (_m *BuilderInterface) Search(columns []string, query string) *qb.Builder {
	ret := _m.Called(columns, query)

	if len(ret) == 0 {
		panic("no return value specified for Search")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func([]string, string) *qb.Builder); ok {
		r0 = rf(columns, query)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Select provides a mock function with given fields: columns
func (_m *BuilderInterface) Select(columns ...string) *qb.Builder {
	_va := make([]interface{}, len(columns))
	for _i := range columns {
		_va[_i] = columns[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Select")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(...string) *qb.Builder); ok {
		r0 = rf(columns...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// SkipLocked provides a mock function with no fields
func (_m *BuilderInterface) SkipLocked() *qb.Builder {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SkipLocked")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func() *qb.Builder); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// SoftDelete provides a mock function with no fields
func (_m *BuilderInterface) SoftDelete() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for SoftDelete")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubQuery provides a mock function with given fields: alias
func (_m *BuilderInterface) SubQuery(alias string) *qb.Builder {
	ret := _m.Called(alias)

	if len(ret) == 0 {
		panic("no return value specified for SubQuery")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string) *qb.Builder); ok {
		r0 = rf(alias)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Sum provides a mock function with given fields: column
func (_m *BuilderInterface) Sum(column string) (float64, error) {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Sum")
	}

	var r0 float64
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (float64, error)); ok {
		return rf(column)
	}
	if rf, ok := ret.Get(0).(func(string) float64); ok {
		r0 = rf(column)
	} else {
		r0 = ret.Get(0).(float64)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(column)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Trigger provides a mock function with given fields: event, data
func (_m *BuilderInterface) Trigger(event qb.EventType, data interface{}) {
	_m.Called(event, data)
}

// Union provides a mock function with given fields: other
func (_m *BuilderInterface) Union(other *qb.Builder) *qb.Builder {
	ret := _m.Called(other)

	if len(ret) == 0 {
		panic("no return value specified for Union")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(*qb.Builder) *qb.Builder); ok {
		r0 = rf(other)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// UnionAll provides a mock function with given fields: other
func (_m *BuilderInterface) UnionAll(other *qb.Builder) *qb.Builder {
	ret := _m.Called(other)

	if len(ret) == 0 {
		panic("no return value specified for UnionAll")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(*qb.Builder) *qb.Builder); ok {
		r0 = rf(other)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Update provides a mock function with given fields: data, fields
func (_m *BuilderInterface) Update(data interface{}, fields ...string) error {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Update")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(interface{}, ...string) error); ok {
		r0 = rf(data, fields...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateAsync provides a mock function with given fields: data, fields
func (_m *BuilderInterface) UpdateAsync(data interface{}, fields ...string) chan error {
	_va := make([]interface{}, len(fields))
	for _i := range fields {
		_va[_i] = fields[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, data)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for UpdateAsync")
	}

	var r0 chan error
	if rf, ok := ret.Get(0).(func(interface{}, ...string) chan error); ok {
		r0 = rf(data, fields...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan error)
		}
	}

	return r0
}

// UpdateMap provides a mock function with given fields: data
func (_m *BuilderInterface) UpdateMap(data map[string]interface{}) error {
	ret := _m.Called(data)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMap")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) error); ok {
		r0 = rf(data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpdateMapAsync provides a mock function with given fields: data
func (_m *BuilderInterface) UpdateMapAsync(data map[string]interface{}) chan error {
	ret := _m.Called(data)

	if len(ret) == 0 {
		panic("no return value specified for UpdateMapAsync")
	}

	var r0 chan error
	if rf, ok := ret.Get(0).(func(map[string]interface{}) chan error); ok {
		r0 = rf(data)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan error)
		}
	}

	return r0
}

// Value provides a mock function with given fields: column
func (_m *BuilderInterface) Value(column string) (interface{}, error) {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Value")
	}

	var r0 interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (interface{}, error)); ok {
		return rf(column)
	}
	if rf, ok := ret.Get(0).(func(string) interface{}); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(column)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Values provides a mock function with given fields: column
func (_m *BuilderInterface) Values(column string) ([]interface{}, error) {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for Values")
	}

	var r0 []interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]interface{}, error)); ok {
		return rf(column)
	}
	if rf, ok := ret.Get(0).(func(string) []interface{}); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(column)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Where provides a mock function with given fields: condition, args
func (_m *BuilderInterface) Where(condition string, args ...interface{}) *qb.Builder {
	var _ca []interface{}
	_ca = append(_ca, condition)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for Where")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *qb.Builder); ok {
		r0 = rf(condition, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereAge provides a mock function with given fields: column, operator, age
func (_m *BuilderInterface) WhereAge(column string, operator string, age int) *qb.Builder {
	ret := _m.Called(column, operator, age)

	if len(ret) == 0 {
		panic("no return value specified for WhereAge")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, int) *qb.Builder); ok {
		r0 = rf(column, operator, age)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereBetween provides a mock function with given fields: column, start, end
func (_m *BuilderInterface) WhereBetween(column string, start interface{}, end interface{}) *qb.Builder {
	ret := _m.Called(column, start, end)

	if len(ret) == 0 {
		panic("no return value specified for WhereBetween")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}) *qb.Builder); ok {
		r0 = rf(column, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereBetweenDateTime provides a mock function with given fields: column, start, end
func (_m *BuilderInterface) WhereBetweenDateTime(column string, start time.Time, end time.Time) *qb.Builder {
	ret := _m.Called(column, start, end)

	if len(ret) == 0 {
		panic("no return value specified for WhereBetweenDateTime")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, time.Time, time.Time) *qb.Builder); ok {
		r0 = rf(column, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereBetweenDates provides a mock function with given fields: column, start, end
func (_m *BuilderInterface) WhereBetweenDates(column string, start time.Time, end time.Time) *qb.Builder {
	ret := _m.Called(column, start, end)

	if len(ret) == 0 {
		panic("no return value specified for WhereBetweenDates")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, time.Time, time.Time) *qb.Builder); ok {
		r0 = rf(column, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereBusinessDays provides a mock function with given fields: column
func (_m *BuilderInterface) WhereBusinessDays(column string) *qb.Builder {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for WhereBusinessDays")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string) *qb.Builder); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereCurrentDate provides a mock function with given fields: column, operator
func (_m *BuilderInterface) WhereCurrentDate(column string, operator string) *qb.Builder {
	ret := _m.Called(column, operator)

	if len(ret) == 0 {
		panic("no return value specified for WhereCurrentDate")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string) *qb.Builder); ok {
		r0 = rf(column, operator)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereDate provides a mock function with given fields: column, operator, value
func (_m *BuilderInterface) WhereDate(column string, operator string, value time.Time) *qb.Builder {
	ret := _m.Called(column, operator, value)

	if len(ret) == 0 {
		panic("no return value specified for WhereDate")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, time.Time) *qb.Builder); ok {
		r0 = rf(column, operator, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereDateBetweenColumns provides a mock function with given fields: dateColumn, startColumn, endColumn
func (_m *BuilderInterface) WhereDateBetweenColumns(dateColumn string, startColumn string, endColumn string) *qb.Builder {
	ret := _m.Called(dateColumn, startColumn, endColumn)

	if len(ret) == 0 {
		panic("no return value specified for WhereDateBetweenColumns")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, string) *qb.Builder); ok {
		r0 = rf(dateColumn, startColumn, endColumn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereDateDiff provides a mock function with given fields: column1, column2, operator, days
func (_m *BuilderInterface) WhereDateDiff(column1 string, column2 string, operator string, days int) *qb.Builder {
	ret := _m.Called(column1, column2, operator, days)

	if len(ret) == 0 {
		panic("no return value specified for WhereDateDiff")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, string, int) *qb.Builder); ok {
		r0 = rf(column1, column2, operator, days)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereDateFormat provides a mock function with given fields: column, format, operator, value
func (_m *BuilderInterface) WhereDateFormat(column string, format string, operator string, value string) *qb.Builder {
	ret := _m.Called(column, format, operator, value)

	if len(ret) == 0 {
		panic("no return value specified for WhereDateFormat")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, string, string) *qb.Builder); ok {
		r0 = rf(column, format, operator, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereDateIsNotNull provides a mock function with given fields: column
func (_m *BuilderInterface) WhereDateIsNotNull(column string) *qb.Builder {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for WhereDateIsNotNull")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string) *qb.Builder); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereDateIsNull provides a mock function with given fields: column
func (_m *BuilderInterface) WhereDateIsNull(column string) *qb.Builder {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for WhereDateIsNull")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string) *qb.Builder); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereDateRange provides a mock function with given fields: column, start, end, inclusive
func (_m *BuilderInterface) WhereDateRange(column string, start time.Time, end time.Time, inclusive bool) *qb.Builder {
	ret := _m.Called(column, start, end, inclusive)

	if len(ret) == 0 {
		panic("no return value specified for WhereDateRange")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, time.Time, time.Time, bool) *qb.Builder); ok {
		r0 = rf(column, start, end, inclusive)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereDateTime provides a mock function with given fields: column, operator, value
func (_m *BuilderInterface) WhereDateTime(column string, operator string, value time.Time) *qb.Builder {
	ret := _m.Called(column, operator, value)

	if len(ret) == 0 {
		panic("no return value specified for WhereDateTime")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, time.Time) *qb.Builder); ok {
		r0 = rf(column, operator, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereDateTrunc provides a mock function with given fields: part, column, operator, value
func (_m *BuilderInterface) WhereDateTrunc(part string, column string, operator string, value time.Time) *qb.Builder {
	ret := _m.Called(part, column, operator, value)

	if len(ret) == 0 {
		panic("no return value specified for WhereDateTrunc")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, string, time.Time) *qb.Builder); ok {
		r0 = rf(part, column, operator, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereDay provides a mock function with given fields: column, operator, day
func (_m *BuilderInterface) WhereDay(column string, operator string, day int) *qb.Builder {
	ret := _m.Called(column, operator, day)

	if len(ret) == 0 {
		panic("no return value specified for WhereDay")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, int) *qb.Builder); ok {
		r0 = rf(column, operator, day)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereExists provides a mock function with given fields: subQuery
func (_m *BuilderInterface) WhereExists(subQuery *qb.Builder) *qb.Builder {
	ret := _m.Called(subQuery)

	if len(ret) == 0 {
		panic("no return value specified for WhereExists")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(*qb.Builder) *qb.Builder); ok {
		r0 = rf(subQuery)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereGroup provides a mock function with given fields: fn
func (_m *BuilderInterface) WhereGroup(fn func(*qb.Builder)) *qb.Builder {
	ret := _m.Called(fn)

	if len(ret) == 0 {
		panic("no return value specified for WhereGroup")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(func(*qb.Builder)) *qb.Builder); ok {
		r0 = rf(fn)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereId provides a mock function with given fields: id
func (_m *BuilderInterface) WhereId(id interface{}) *qb.Builder {
	ret := _m.Called(id)

	if len(ret) == 0 {
		panic("no return value specified for WhereId")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(interface{}) *qb.Builder); ok {
		r0 = rf(id)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereIn provides a mock function with given fields: column, values
func (_m *BuilderInterface) WhereIn(column string, values ...interface{}) *qb.Builder {
	var _ca []interface{}
	_ca = append(_ca, column)
	_ca = append(_ca, values...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WhereIn")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *qb.Builder); ok {
		r0 = rf(column, values...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereLastDays provides a mock function with given fields: column, days
func (_m *BuilderInterface) WhereLastDays(column string, days int) *qb.Builder {
	ret := _m.Called(column, days)

	if len(ret) == 0 {
		panic("no return value specified for WhereLastDays")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, int) *qb.Builder); ok {
		r0 = rf(column, days)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereMonth provides a mock function with given fields: column, operator, month
func (_m *BuilderInterface) WhereMonth(column string, operator string, month int) *qb.Builder {
	ret := _m.Called(column, operator, month)

	if len(ret) == 0 {
		panic("no return value specified for WhereMonth")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, int) *qb.Builder); ok {
		r0 = rf(column, operator, month)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereNextDays provides a mock function with given fields: column, days
func (_m *BuilderInterface) WhereNextDays(column string, days int) *qb.Builder {
	ret := _m.Called(column, days)

	if len(ret) == 0 {
		panic("no return value specified for WhereNextDays")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, int) *qb.Builder); ok {
		r0 = rf(column, days)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereNotBetween provides a mock function with given fields: column, start, end
func (_m *BuilderInterface) WhereNotBetween(column string, start interface{}, end interface{}) *qb.Builder {
	ret := _m.Called(column, start, end)

	if len(ret) == 0 {
		panic("no return value specified for WhereNotBetween")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, interface{}, interface{}) *qb.Builder); ok {
		r0 = rf(column, start, end)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereNotExists provides a mock function with given fields: subQuery
func (_m *BuilderInterface) WhereNotExists(subQuery *qb.Builder) *qb.Builder {
	ret := _m.Called(subQuery)

	if len(ret) == 0 {
		panic("no return value specified for WhereNotExists")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(*qb.Builder) *qb.Builder); ok {
		r0 = rf(subQuery)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereNotNull provides a mock function with given fields: column
func (_m *BuilderInterface) WhereNotNull(column string) *qb.Builder {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for WhereNotNull")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string) *qb.Builder); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereNull provides a mock function with given fields: column
func (_m *BuilderInterface) WhereNull(column string) *qb.Builder {
	ret := _m.Called(column)

	if len(ret) == 0 {
		panic("no return value specified for WhereNull")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string) *qb.Builder); ok {
		r0 = rf(column)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereQuarter provides a mock function with given fields: column, operator, quarter
func (_m *BuilderInterface) WhereQuarter(column string, operator string, quarter int) *qb.Builder {
	ret := _m.Called(column, operator, quarter)

	if len(ret) == 0 {
		panic("no return value specified for WhereQuarter")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, int) *qb.Builder); ok {
		r0 = rf(column, operator, quarter)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereRaw provides a mock function with given fields: sql, args
func (_m *BuilderInterface) WhereRaw(sql string, args ...interface{}) *qb.Builder {
	var _ca []interface{}
	_ca = append(_ca, sql)
	_ca = append(_ca, args...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for WhereRaw")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, ...interface{}) *qb.Builder); ok {
		r0 = rf(sql, args...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereSubQuery provides a mock function with given fields: column, operator, subQuery
func (_m *BuilderInterface) WhereSubQuery(column string, operator string, subQuery *qb.Builder) *qb.Builder {
	ret := _m.Called(column, operator, subQuery)

	if len(ret) == 0 {
		panic("no return value specified for WhereSubQuery")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, *qb.Builder) *qb.Builder); ok {
		r0 = rf(column, operator, subQuery)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereTime provides a mock function with given fields: column, operator, value
func (_m *BuilderInterface) WhereTime(column string, operator string, value time.Time) *qb.Builder {
	ret := _m.Called(column, operator, value)

	if len(ret) == 0 {
		panic("no return value specified for WhereTime")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, time.Time) *qb.Builder); ok {
		r0 = rf(column, operator, value)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereTimeWindow provides a mock function with given fields: column, startTime, endTime
func (_m *BuilderInterface) WhereTimeWindow(column string, startTime time.Time, endTime time.Time) *qb.Builder {
	ret := _m.Called(column, startTime, endTime)

	if len(ret) == 0 {
		panic("no return value specified for WhereTimeWindow")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, time.Time, time.Time) *qb.Builder); ok {
		r0 = rf(column, startTime, endTime)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereTimeZone provides a mock function with given fields: column, operator, value, timezone
func (_m *BuilderInterface) WhereTimeZone(column string, operator string, value time.Time, timezone string) *qb.Builder {
	ret := _m.Called(column, operator, value, timezone)

	if len(ret) == 0 {
		panic("no return value specified for WhereTimeZone")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, time.Time, string) *qb.Builder); ok {
		r0 = rf(column, operator, value, timezone)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereWeek provides a mock function with given fields: column, operator, week
func (_m *BuilderInterface) WhereWeek(column string, operator string, week int) *qb.Builder {
	ret := _m.Called(column, operator, week)

	if len(ret) == 0 {
		panic("no return value specified for WhereWeek")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, int) *qb.Builder); ok {
		r0 = rf(column, operator, week)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereWeekday provides a mock function with given fields: column, operator, weekday
func (_m *BuilderInterface) WhereWeekday(column string, operator string, weekday int) *qb.Builder {
	ret := _m.Called(column, operator, weekday)

	if len(ret) == 0 {
		panic("no return value specified for WhereWeekday")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, int) *qb.Builder); ok {
		r0 = rf(column, operator, weekday)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WhereYear provides a mock function with given fields: column, operator, year
func (_m *BuilderInterface) WhereYear(column string, operator string, year int) *qb.Builder {
	ret := _m.Called(column, operator, year)

	if len(ret) == 0 {
		panic("no return value specified for WhereYear")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, int) *qb.Builder); ok {
		r0 = rf(column, operator, year)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// Window provides a mock function with given fields: column, partition, orderBy
func (_m *BuilderInterface) Window(column string, partition string, orderBy string) *qb.Builder {
	ret := _m.Called(column, partition, orderBy)

	if len(ret) == 0 {
		panic("no return value specified for Window")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string, string) *qb.Builder); ok {
		r0 = rf(column, partition, orderBy)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WithAudit provides a mock function with given fields: userID
func (_m *BuilderInterface) WithAudit(userID interface{}) *qb.Builder {
	ret := _m.Called(userID)

	if len(ret) == 0 {
		panic("no return value specified for WithAudit")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(interface{}) *qb.Builder); ok {
		r0 = rf(userID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WithMetrics provides a mock function with given fields: collector
func (_m *BuilderInterface) WithMetrics(collector *qb.MetricsCollector) *qb.Builder {
	ret := _m.Called(collector)

	if len(ret) == 0 {
		panic("no return value specified for WithMetrics")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(*qb.MetricsCollector) *qb.Builder); ok {
		r0 = rf(collector)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WithTransaction provides a mock function with given fields: tx
func (_m *BuilderInterface) WithTransaction(tx *qb.Transaction) *qb.Builder {
	ret := _m.Called(tx)

	if len(ret) == 0 {
		panic("no return value specified for WithTransaction")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(*qb.Transaction) *qb.Builder); ok {
		r0 = rf(tx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WithTrashed provides a mock function with no fields
func (_m *BuilderInterface) WithTrashed() *qb.Builder {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for WithTrashed")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func() *qb.Builder); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// WithinGroup provides a mock function with given fields: column, window
func (_m *BuilderInterface) WithinGroup(column string, window string) *qb.Builder {
	ret := _m.Called(column, window)

	if len(ret) == 0 {
		panic("no return value specified for WithinGroup")
	}

	var r0 *qb.Builder
	if rf, ok := ret.Get(0).(func(string, string) *qb.Builder); ok {
		r0 = rf(column, window)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*qb.Builder)
		}
	}

	return r0
}

// NewBuilderInterface creates a new instance of BuilderInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewBuilderInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *BuilderInterface {
	mock := &BuilderInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
